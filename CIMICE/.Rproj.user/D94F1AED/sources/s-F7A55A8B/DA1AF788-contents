---
title: "Cimice"
output:
  pdf_document: default
  html_notebook: default
---

## Descrizione

Test per provare a realizzare una semplice implementazione di cimice in R (magari meno efficiente)

## Gestione dell'input

Utilizzo per ora direttamente il formato "CAPRI/CAPRESE" ossia:
* una linea rappresenta i nomi dei geni/loci analizzati (il primo elemento della linea è una stringa a scelta)
* ogni linea successiva indica: nome del campione, bit set dello stato di alterazione dei geni/loci

```{r}

library(dplyr)
library(ggplot2)
library(glue)

#dataset = read.csv("/home/redsnic/CIMICE/tumorEvolutionWithMarkovChains/datasets/dataset_NC_002695.CAPRI", sep = " ", row.names=NULL)
dataset = read.csv("/home/redsnic/Documenti/CIMICE/input/ex.in", sep = " ", row.names=NULL)

colnames(dataset)[1] = "Samples"
rownames(dataset) = dataset[,1]

dataset <- dataset %>% select(-Samples)
dataset

```

# Verifica della distribuzione del numero di mutazioni

Per gene: 

```{r}
temp.df <- as.data.frame(t(dataset[,1:nrow(t(dataset))])) 

temp.df$sums <- rowSums(temp.df[,1:ncol(temp.df)], na.rm = TRUE)
nGenes <- nrow(temp.df)

ggplot(temp.df, aes(x=sums)) +
    geom_histogram(color="black", fill="white", binwidth = 1) +
    labs(title = glue("Numero di mutazioni per gene ({nGenes} geni)"), x = "Numero di mutazioni", y = "Conteggio")
```

Per campione:

```{r}
temp.df <- dataset 

temp.df$sums <- rowSums(temp.df[,1:ncol(dataset)], na.rm = TRUE)
nSample <- nrow(temp.df)

ggplot(temp.df, aes(x=sums)) +
    geom_histogram(color="black", fill="white", binwidth = 1) +
    labs(title = glue("Numero di mutazioni per campione ({nSample} campioni)"), x = "Numero di mutazioni", y = "Conteggio")
```

## Selezione degli N geni più mutati


```{r}
n <- 100
# Gestione della colonna dei nomi dei campioni
temp.df <- as.data.frame(t(dataset)) 
# ordinamento per somma
temp.df$sums <- rowSums(temp.df[,1:ncol(temp.df)], na.rm = TRUE)
temp.df <- temp.df[order(-temp.df$sums),][1:n,] %>% select(-sums)
temp.df <- as.data.frame(t(temp.df))
temp.df

```

## Selezione degli N campioni meno mutati

```{r}
n <- 100
temp.df <- dataset

# ordinamento per somma
temp.df$sums <- rowSums(temp.df[,2:ncol(temp.df)], na.rm = TRUE)
temp.df <- temp.df[order(temp.df$sums),][1:n,] %>% select(-sums)
temp.df

```


# Correlation plot

Cerco di vedere se ci sono correlazioni fra le alterazioni di alcuni geni

```{r}

library("ggcorrplot")

d <- dataset 
corr <- round(cor(d), 1)
corr[is.nan(corr)] <- 0
corr[is.na(corr)] <- 0
corr[corr == Inf] <- 0

ggcorrplot(corr, hc.order = TRUE)

```

# Group lines by equality

Raggruppo le linee del dataset in modo da rappresentare le frequenze osservate di ciascun genotipo


```{r}

compactedDataset = dataset %>% plyr::count( colnames(dataset) )
# scritto così elimino i nomi dei campioni
compactedDataset

```

## Graph construction

Costruzione del grafo dei genotipi (relazione di sottoinsieme)

```{r}

library(igraph)

genes = colnames(compactedDataset)[-length(compactedDataset)]
genes
# rimuove la colonna contenente il numero di genotipi osservati per genotipo
samples = as.matrix(compactedDataset %>% select(-freq))

# estrai le frequenze dei vari genotipi
freqs = as.matrix(compactedDataset %>% ungroup() %>% select(freq))
freqs = freqs/sum(freqs)
freqs

# aggiunge il genotipo Clonal al dataset (assume che non sia presente, è da rimuoverlo in caso)
samples = rbind(samples, sapply(1:ncol(samples), function(x) 0) )

```

```{r}
# Costruzione del grafo (relazione di "contenuto")

edges = list()
index = 1

# un semplice ciclo che valuta la relazione contenuto per tutte le coppie di nodi (diversi)
for(i in 1:nrow(samples)){
    for(j in 1:nrow(samples)){
        if(i!=j){
            r1 = samples[i,]
            r2 = samples[j,]
            if( ! ((-1) %in% (r1 - r2)) ) {
                edges[[index]] <- c(j,i)
                index <- index + 1
            }
        }
    }
}

```

```{r}

samples
genes

# preparo le etichette con i geni relativi ai nodi
labels = apply(samples, MARGIN = 1, FUN = function(x) genes[x==1] )
# aggiungo il genotipo Clonal
labels[length(labels)] = "Clonal"
freqs = rbind(freqs, 0)
# preparazione etichette (da vettori di stringhe)
labels = lapply(labels, function (x) paste(x, collapse=", "))


# preparo le etichette con le frequenze osservate dei nodi
g = graph_from_edgelist(t(simplify2array(edges)))
#V(g)$label <- labels # per aggiungere le etichette ai nodi

library("nem")
# rimuovo gli archi transitivi usando un oscuro pacchetto R (che sarà di quelli di OncoNem tra l'altro)
g = graph_from_adjacency_matrix(transitive.reduction(as.matrix(as_adj(g))))

plot.igraph(g)
```


## Situazione attuale

```{r}

freqs
labels
plot(g)
E(g)

```

## Calcolo dei pesi degli archi

```{r}

A = as.matrix(as_adj(g))

# calcolo il no di figli per ogni nodo
no.of.children = seq(0, 0, length.out = length(V(g)))
for( v in V(g) ){
    no.of.children[v] = sum(A[v,])
}

no.of.children

```

Pesi UP

```{r}

upWeights <<- seq(-1, -1, length.out = length(E(g)))

computeUPW = function(edge) {
    
    if (upWeights[edge] != -1) return(upWeights[edge])
    
    source = as_ids(tail_of(g,edge))
    destination = as_ids(head_of(g,edge))
    
    D = no.of.children[source]
    P = freqs[source]
    
    W <- 0
    if(length(which(A[,source] >= 1)) != 0){
        edges.entering.in.source <- lapply( as.list(which(A[,source] >= 1)), function (x) c(x,source) )
        edges.entering.in.source <- get.edge.ids(g, unlist(edges.entering.in.source)) 
        
        W <- sum( sapply( edges.entering.in.source , function (x) computeUPW(x) ) )
    }
    
    upWeights[edge] <<-  (1/D) * (P+W)
    return(upWeights[edge])
}

upWeights <- sapply( 1:length(E(g)), function(x) computeUPW(x) )
upWeights

```
Up Weights Normalization

```{r}

normUpWeights <- seq(-1, -1, length.out = length(E(g)))

for ( v in V(g) ){
    if(length(which(A[,v] >= 1)) != 0){
        edges.entering.in.source <- lapply( as.list(which(A[,v] >= 1)), function (x) c(x,v) )
        edges.entering.in.source <- get.edge.ids(g, unlist(edges.entering.in.source)) 
        normVal <- sum( sapply( edges.entering.in.source , function (x) computeUPW(x) ) )
        print(normVal)
        for(e in edges.entering.in.source){
            if(normVal == 0){ # è l'unico arco
                normUpWeights[e] <- 1
            }else{
                normUpWeights[e] <- upWeights[e]/normVal
            }
        }
    }
}

normUpWeights

```

Down Weights

```{r}

downWeights <<- seq(-1, -1, length.out = length(E(g)))

computeDWNW = function(edge) {
    
    if (downWeights[edge] != -1) return(downWeights[edge])
    
    source = as_ids(tail_of(g,edge))
    destination = as_ids(head_of(g,edge))
    
    UPW = normUpWeights[edge]
    P = freqs[destination]
    
    W <- 0
    if(length(which(A[destination,] >= 1)) != 0){
        edges.exiting.destination <- lapply( as.list(which(A[destination,] >= 1)), function (x) c(destination,x) )
        edges.exiting.destination <- get.edge.ids(g, unlist(edges.exiting.destination)) 
        
        W <- sum( sapply( edges.exiting.destination , function (x) computeDWNW(x) ) )
    }
    
    downWeights[edge] <<-  (UPW) * (P+W)
    return(downWeights[edge])
}

downWeights <- sapply( 1:length(E(g)), function(x) computeDWNW(x) )
downWeights

```

Normalized Down Weights

```{r}

normDownWeights <- seq(-1, -1, length.out = length(E(g)))

for ( v in V(g) ){
    if(length(which(A[v,] >= 1)) != 0){
        edges.exiting.source <- lapply( as.list(which(A[v,] >= 1)), function (x) c(v,x) )
        edges.exiting.source <- get.edge.ids(g, unlist(edges.exiting.source)) 
        normVal <- sum( sapply( edges.exiting.source , function (x) computeDWNW(x) ) )
        print(normVal)
        for(e in edges.exiting.source){
            if(normVal == 0){ # è l'unico arco
                normDownWeights[e] <- 1
            }else{
                normDownWeights[e] <- downWeights[e]/normVal
            }
        }
    }
}

normDownWeights

```

Situazione attuale:

```{r}

upWeights
normUpWeights
downWeights
normDownWeights

V(g)$label <- labels # per aggiungere le etichette ai nodi
E(g)$label <- normDownWeights

library(ggraph)
library(tidygraph)

normDW = signif(normDownWeights, digits = 4)

ggraph(g, layout = "auto") +
    geom_node_point() +
    geom_node_label(aes(label=labels)) +
    geom_edge_link(
        aes(label=normDW, start_cap = label_rect(node1.label), end_cap = label_rect(node2.label)),
        arrow = arrow(length = unit(4, 'mm')),
        label_dodge = unit(2.5, 'mm'),
        angle_calc = 'along',
       
        ) 



```

```{r}
# run ALL
```

