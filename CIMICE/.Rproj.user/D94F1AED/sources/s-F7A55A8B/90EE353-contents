

library(dplyr)
library(ggplot2)

dataset = read.csv("/home/redsnic/CIMICE/tumorEvolutionWithMarkovChains/datasets/dataset_NC_002695.CAPRI", sep = " ", row.names=NULL)
#dataset = read.csv("/home/redsnic/Documenti/CIMICE/input/ex.in", sep = " ", row.names=NULL)

colnames(dataset)[1] = "Samples"

dataset

library("ggcorrplot")

d <- dataset %>% select(-"Samples")
corr <- round(cor(d), 1)
corr[is.nan(corr)] <- 0
corr[is.na(corr)] <- 0
corr[corr == Inf] <- 0


colnames(dataset[,-1])
compactedDataset = dataset[,-1] %>% plyr::count( colnames(dataset[-1]) )
# scritto così elimino i nomi dei campioni
compactedDataset

library(igraph)

genes = colnames(compactedDataset)[-length(compactedDataset)]
genes
# rimuove la colonna contenente il numero di genotipi osservati per genotipo
samples = as.matrix(compactedDataset %>% select(-freq))

# estrai le frequenze dei vari genotipi
freqs = as.matrix(compactedDataset %>% ungroup() %>% select(freq))
freqs = freqs/sum(freqs)
freqs

# aggiunge il genotipo Clonal al dataset (assume che non sia presente, è da rimuoverlo in caso)
samples = rbind(samples, sapply(1:ncol(samples), function(x) 0) )

# Costruzione del grafo (relazione di "contenuto")

edges = list()
index = 1

# un semplice ciclo che valuta la relazione contenuto per tutte le coppie di nodi (diversi)
for(i in 1:nrow(samples)){
    for(j in 1:nrow(samples)){
        if(i!=j){
            r1 = samples[i,]
            r2 = samples[j,]
            if( ! ((-1) %in% (r1 - r2)) ) {
                edges[[index]] <- c(j,i)
                index <- index + 1
            }
        }
    }
}



samples
genes

# preparo le etichette con i geni relativi ai nodi
labels = apply(samples, MARGIN = 1, FUN = function(x) genes[x==1] )
# aggiungo il genotipo Clonal
labels[length(labels)] = "Clonal"
freqs = rbind(freqs, 0)
# preparazione etichette (da vettori di stringhe)
labels = lapply(labels, function (x) paste(x, collapse=", "))


# preparo le etichette con le frequenze osservate dei nodi
g = graph_from_edgelist(t(simplify2array(edges)))
#V(g)$label <- labels # per aggiungere le etichette ai nodi

library("nem")
# rimuovo gli archi transitivi usando un oscuro pacchetto R (che sarà di quelli di OncoNem tra l'altro)
g = graph_from_adjacency_matrix(transitive.reduction(as.matrix(as_adj(g))))

plot.igraph(g)


freqs
labels
plot(g)
E(g)



A = as.matrix(as_adj(g))

# calcolo il no di figli per ogni nodo
no.of.children = seq(0, 0, length.out = length(V(g)))
for( v in V(g) ){
    no.of.children[v] = sum(A[v,])
}

no.of.children



upWeights <<- seq(-1, -1, length.out = length(E(g)))

computeUPW = function(edge) {
    
    if (upWeights[edge] != -1) return(upWeights[edge])
    
    source = as_ids(tail_of(g,edge))
    destination = as_ids(head_of(g,edge))
    
    D = no.of.children[source]
    P = freqs[source]
    
    W <- 0
    if(length(which(A[,source] >= 1)) != 0){
        edges.entering.in.source <- lapply( as.list(which(A[,source] >= 1)), function (x) c(x,source) )
        edges.entering.in.source <- get.edge.ids(g, unlist(edges.entering.in.source)) 
        
        W <- sum( sapply( edges.entering.in.source , function (x) computeUPW(x) ) )
    }
    
    upWeights[edge] <<-  (1/D) * (P+W)
    return(upWeights[edge])
}

upWeights <- sapply( 1:length(E(g)), function(x) computeUPW(x) )
upWeights


normUpWeights <- seq(-1, -1, length.out = length(E(g)))

for ( v in V(g) ){
    if(length(which(A[,v] >= 1)) != 0){
        edges.entering.in.source <- lapply( as.list(which(A[,v] >= 1)), function (x) c(x,v) )
        edges.entering.in.source <- get.edge.ids(g, unlist(edges.entering.in.source)) 
        normVal <- sum( sapply( edges.entering.in.source , function (x) computeUPW(x) ) )
        print(normVal)
        for(e in edges.entering.in.source){
            if(normVal == 0){ # è l'unico arco
                normUpWeights[e] <- 1
            }else{
                normUpWeights[e] <- upWeights[e]/normVal
            }
        }
    }
}

normUpWeights

downWeights <<- seq(-1, -1, length.out = length(E(g)))

computeDWNW = function(edge) {
    
    if (downWeights[edge] != -1) return(downWeights[edge])
    
    source = as_ids(tail_of(g,edge))
    destination = as_ids(head_of(g,edge))
    
    UPW = normUpWeights[edge]
    P = freqs[destination]
    
    W <- 0
    if(length(which(A[destination,] >= 1)) != 0){
        edges.exiting.destination <- lapply( as.list(which(A[destination,] >= 1)), function (x) c(destination,x) )
        edges.exiting.destination <- get.edge.ids(g, unlist(edges.exiting.destination)) 
        
        W <- sum( sapply( edges.exiting.destination , function (x) computeDWNW(x) ) )
    }
    
    downWeights[edge] <<-  (UPW) * (P+W)
    return(downWeights[edge])
}

downWeights <- sapply( 1:length(E(g)), function(x) computeDWNW(x) )
downWeights

normDownWeights <- seq(-1, -1, length.out = length(E(g)))

for ( v in V(g) ){
    if(length(which(A[v,] >= 1)) != 0){
        edges.exiting.source <- lapply( as.list(which(A[v,] >= 1)), function (x) c(v,x) )
        edges.exiting.source <- get.edge.ids(g, unlist(edges.exiting.source)) 
        normVal <- sum( sapply( edges.exiting.source , function (x) computeDWNW(x) ) )
        print(normVal)
        for(e in edges.exiting.source){
            if(normVal == 0){ # è l'unico arco
                normDownWeights[e] <- 1
            }else{
                normDownWeights[e] <- downWeights[e]/normVal
            }
        }
    }
}

normDownWeights

upWeights
normUpWeights
downWeights
normDownWeights

V(g)$label <- labels # per aggiungere le etichette ai nodi
E(g)$label <- normDownWeights

library(ggraph)
library(tidygraph)

normDW = signif(normDownWeights, digits = 4)

    ggraph(g, layout = "auto") +
        geom_node_point() +
        geom_node_label(aes(label=labels)) +
        geom_edge_link(
            aes(label=normDW, start_cap = label_rect(node1.label), end_cap = label_rect(node2.label)),
            arrow = arrow(length = unit(4, 'mm')),
            label_dodge = unit(2.5, 'mm'),
            angle_calc = 'along',
           
            ) 


